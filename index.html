<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (sRGB + Shadow + GUI + Pins)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}
    .hint{
      position:fixed;left:10px;bottom:10px;color:#cfd8dc;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:.85;user-select:none;background:rgba(0,0,0,.35);
      padding:6px 8px;border-radius:6px;
      z-index: 5;
    }

    /* ===== オーバーレイ小ウィンドウ ===== */
    #overlay {
      position: fixed;  
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(50vw);
      height: min(60vh);
      background: #111;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      overflow: hidden;
      display: none;
      z-index: 10; /* GUIより前に出す */
    }
    #overlay.visible {
      display: block;
    }
    #overlay-header {
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 8px;
      background: rgba(20,20,20,0.95);
      color: #eee;
      font: 12px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      cursor: move; /* 将来ドラッグ対応したくなったとき用の見た目 */
    }
    #overlay-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(100% - 40px);
    }
    #overlay-close {
      border: none;
      background: transparent;
      color: #ccc;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
    }
    #overlay-close:hover {
      color: #fff;
    }

    #overlay-iframe {
      width: 100%;
      height: calc(100% - 28px);
      border: none;
      background: #000;
    }

    /* 上端中央のタイトル用 */
    #top-title{
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 4;
      pointer-events: none;
    }
    #top-title img{
      display: block;
      max-width: 90vw;  /* 画面より大きくならないように */
      height: auto;
    }

    
  </style>

  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    } }
  </script>
</head>
<body>
<div id="app"></div>

<div id="top-title">
  <img src="./title.png" alt="藤原の里 3D ビューア">
</div>
  
<!-- 小さめタブ（オーバーレイ） -->
<div id="overlay">
  <div id="overlay-header">
    <div id="overlay-title">Loading…</div>
    <button id="overlay-close" aria-label="Close">✕</button>
  </div>
  <iframe id="overlay-iframe" src="about:blank" allowfullscreen></iframe>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

  // ========================= 基本セットアップ =========================
  const DEFAULT_BG = '#c2c2c2';

  const container = document.getElementById('app');

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(DEFAULT_BG);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(0, 40, 80);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;
  controls.target.set(0, 0, 0);

  // 「軌道」用の基準ビュー（オートローテで回っている円周上の1点）
  const baseOrbitPos = new THREE.Vector3();
  const baseOrbitTarget = new THREE.Vector3();
  let hasBaseOrbit = false;

  // ピンクリック直前の「その時点の軌道上の位置」
  const orbitPosBeforeFly = new THREE.Vector3();
  const orbitTargetBeforeFly = new THREE.Vector3();
  let hasOrbitBeforeFly = false;

  // 無操作10秒で軌道に戻るためのタイマー
  const IDLE_TIMEOUT_MS = 10000;
  let lastUserInputTime = performance.now();
  let idleReturnArmed = false;

  function markUserInteraction(){
    lastUserInputTime = performance.now();
    idleReturnArmed = true;
  }

  // OrbitControlsの操作開始/終了でも「操作あり」とみなす
  controls.addEventListener('start', markUserInteraction);
  controls.addEventListener('end', markUserInteraction);

  // ライティング
  const ambient = new THREE.AmbientLight(0xffffff, 1.0);
  scene.add(ambient);
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(3, 5, 2).multiplyScalar(100);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 1000;
  sun.shadow.camera.left = -300;
  sun.shadow.camera.right = 300;
  sun.shadow.camera.top = 300;
  sun.shadow.camera.bottom = -300;
  scene.add(sun);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.ShadowMaterial({ opacity: 0.25 }));
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.01;
  ground.receiveShadow = true;
  ground.visible = false;
  scene.add(ground);

  const axes = new THREE.AxesHelper(100);
  scene.add(axes);
  axes.visible = false; 
  
  // ========================= オーバーレイ要素 =========================
  const overlay       = document.getElementById('overlay');
  const overlayTitle  = document.getElementById('overlay-title');
  const overlayFrame  = document.getElementById('overlay-iframe');
  const overlayClose  = document.getElementById('overlay-close');

  let overlayPrevAutoRotate = controls.autoRotate;

  function toEmbedUrl(rawHref){
    // YouTube のショートURL / 通常URL を埋め込みURLに変換
    try{
      const u = new URL(rawHref);
      const host = u.hostname;
      if (host.includes('youtu.be')) {
        const id = u.pathname.replace('/', '');
        if (id) return `https://www.youtube.com/embed/${id}?autoplay=1`;
      }
      if (host.includes('youtube.com') && u.searchParams.get('v')) {
        const id = u.searchParams.get('v');
        return `https://www.youtube.com/embed/${id}?autoplay=1`;
      }
    }catch(e){
      // URL としてパースできなければそのまま返す
    }
    return rawHref;
  }

  function openOverlay(href){
    if (!href) return;
    markUserInteraction();
    overlayPrevAutoRotate = controls.autoRotate;
    controls.autoRotate = false;

    const displayTitle = href.length > 60 ? href.slice(0, 57) + '…' : href;
    overlayTitle.textContent = displayTitle;

    const url = toEmbedUrl(href);
    overlayFrame.src = url;
    overlay.classList.add('visible');
  }

  overlayClose.addEventListener('click', ()=>{
    markUserInteraction();
    overlay.classList.remove('visible');
    overlayFrame.src = 'about:blank';

    // ピンクリック直前の軌道位置があればそこへ、それが無ければ基準軌道へ戻る
    let destPos = null;
    let destTarget = null;
    if (hasOrbitBeforeFly) {
      destPos = orbitPosBeforeFly.clone();
      destTarget = orbitTargetBeforeFly.clone();
    } else if (hasBaseOrbit) {
      destPos = baseOrbitPos.clone();
      destTarget = baseOrbitTarget.clone();
    }

    hasOrbitBeforeFly = false;

    if (destPos && destTarget) {
      flyTo(
        camera,
        controls,
        destPos,
        destTarget,
        1800,
        ()=>{
          if (overlayPrevAutoRotate){
            controls.autoRotate = true;
            params.autoRotate = true;
          }
        }
      );
    } else {
      // 保険：何も保存されていない場合
      if (overlayPrevAutoRotate){
        controls.autoRotate = true;
        params.autoRotate = true;
      }
    }
  });

  // ========================= Raycaster & 状態 =========================
  const raycaster = new THREE.Raycaster();
  const mouseNDC = new THREE.Vector2();

  renderer.domElement.addEventListener('pointermove', (e)=>{
    const r = renderer.domElement.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - r.top) / r.height) * 2 + 1;
  });

  // カメラ操作系のユーザー入力
  renderer.domElement.addEventListener('pointerdown', markUserInteraction);
  renderer.domElement.addEventListener('wheel', markUserInteraction);
  window.addEventListener('keydown', markUserInteraction);

  let root = null;
  const clickableObjects = []; // ピン（リンクあり/なし）
  let hoverObject = null;

  // ========================= テクスチャキャッシュ =========================
  const texCache = new Map();
  function loadTex(url){
    if (!url) return null;
    if (texCache.has(url)) return texCache.get(url);
    const t = new THREE.TextureLoader().load(url);
    texCache.set(url, t);
    return t;
  }

  // ========================= カメラ飛行ユーティリティ =========================
  let _flying = false;
  function flyTo(camera, controls, destPos, destLook, duration = 1600, onDone){
    if (_flying) return;
    _flying = true;
    const startPos  = camera.position.clone();
    const startLook = controls.target.clone();
    const easeInOutCubic = (t)=> t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    const t0 = performance.now();

    const prevEnabled = controls.enabled;
    const prevAutoRotate = controls.autoRotate;
    controls.enabled = false;
    controls.autoRotate = false;

    function step(now){
      const t = Math.min(1, (now - t0) / duration);
      const k = easeInOutCubic(t);
      camera.position.lerpVectors(startPos, destPos, k);
      controls.target.lerpVectors(startLook, destLook, k);
      camera.lookAt(controls.target);
      if (t < 1){
        requestAnimationFrame(step);
      } else {
        controls.enabled = prevEnabled;
        controls.autoRotate = prevAutoRotate;
        _flying = false;
        onDone && onDone();
      }
    }
    requestAnimationFrame(step);
  }

  // ========================= ラベル付きスプライト生成（アスペクト保持） =========================
  function attachLabelSprite(parent, texLabel, heightWorld = 4, offset=[0,2,0]){
    if (!texLabel) return null;
    const matLabel = new THREE.SpriteMaterial({ map: texLabel, transparent: true, depthTest: true });
    const label = new THREE.Sprite(matLabel);
    label.scale.set(heightWorld, heightWorld, 1); // 仮
    label.position.set(...offset);
    label.visible = true;
    label.userData = { fitByImage: true, targetH: heightWorld };
    parent.add(label);
    return label;
  }

  // 共通ピン
  function createPin({
    pos=[0,0,0], href=null, iconBlue, iconRed, labelPng=null,
    scale=3, labelHeight=4, labelOffset=[0,2,0], noColorSwap=false
  }) {
    const texBlue  = loadTex(iconBlue);
    const texRed   = iconRed ? loadTex(iconRed) : texBlue;
    const texLabel = labelPng ? loadTex(labelPng) : null;

    const matBlue = new THREE.SpriteMaterial({ map: texBlue, transparent: true });
    const matRed  = new THREE.SpriteMaterial({ map: texRed,  transparent: true });

    const pin = new THREE.Sprite(matBlue);
    pin.position.set(...pos);
    pin.scale.setScalar(scale);
    pin.renderOrder = 10;
    pin.userData = { href, type:'pin', mats:{blue:matBlue, red:matRed}, label:null, noColorSwap };

    if (texLabel) {
      const label = attachLabelSprite(pin, texLabel, labelHeight, labelOffset);
      pin.userData.label = label;
    }
    return pin;
  }

  // 疑似回転ピン
  function createSpinningPin({
    pos=[0,0,0], href=null, icon='./pinbrightred.png',
    baseScale=6, spinSpeed=0.8, minFactor=0.06, labelPng=null, labelHeight=5, labelOffset=[0,3.2,0]
  }){
    const tex = loadTex(icon);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
    const sp = new THREE.Sprite(mat);
    sp.position.set(...pos);
    sp.scale.set(baseScale, baseScale, 1);
    sp.renderOrder = 11;
    sp.userData = {
      type:'pin', href,
      mats:{blue:mat, red:mat},
      label:null, noColorSwap:true,
      spin:{ base:baseScale, speed:spinSpeed, phase: Math.random()*Math.PI*2, min:minFactor }
    };
    if (labelPng){
      const labelTex = loadTex(labelPng);
      sp.userData.label = attachLabelSprite(sp, labelTex, labelHeight, labelOffset);
    }
    return sp;
  }

  // ========================= モデル読込 =========================
  const clickableSpinPins = [];
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('./100.glb', (gltf) => {
    root = gltf.scene;
    root.traverse(o => { if (o.isMesh){ o.castShadow = true; o.receiveShadow = false; }});
    scene.add(root);

    // フィット
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(), center = new THREE.Vector3();
    box.getSize(size); box.getCenter(center);
    root.position.sub(center);
    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.6;
    camera.position.set(dist*0.3, dist*0.2, dist*0.3);
    controls.target.set(0,0,0);
    controls.update();

    // この時のビューを「軌道の基準位置」として保存
    baseOrbitPos.copy(camera.position);
    baseOrbitTarget.copy(controls.target);
    hasBaseOrbit = true;

    // ===== 青ピン =====
    const pin1 = createPin({            //イベント広場
      pos: [-14, 3, -20],
      href: './eventarea.mp4',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './event.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin1); clickableObjects.push(pin1);

    const pin2 = createPin({           //金色堂
      pos: [-37, 15, 41],
      href: './konjikido.mp4',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './konjiki.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin2); clickableObjects.push(pin2);

    const pin3 = createPin({           //無量光院
      pos: [-37, 3, 20],
      href: './muryou.mp4',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './muryou.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin3); clickableObjects.push(pin3);

const pin4 = createPin({           //義経持仏堂
      pos: [0, 10, 22],
      href: './yoshitsune.mp4',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './yositsune.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin4); clickableObjects.push(pin4);

const pin5 = createPin({           //政庁南（天球）
      pos: [-17, 3, 7],
      href: 'https://tadappi.github.io/FU-seichoS/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './seichoS.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin5); clickableObjects.push(pin5);

const pin6 = createPin({           //町並み（天球）
      pos: [-30, 3, 5],
      href: 'https://tadappi.github.io/FU-machi/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './machi.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin6); clickableObjects.push(pin6);

const pin7 = createPin({           //城柵ゾーン（天球）
      pos: [-14, 6, 55],
      href: 'https://tadappi.github.io/FU-jyosaku/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './jyosaku.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin7); clickableObjects.push(pin7);

const pin8 = createPin({           //安宅関（天球）
      pos: [0, 12, 47],
      href: 'https://tadappi.github.io/FU-atakaseki/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './ataka.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin8); clickableObjects.push(pin8);

 const pin9 = createPin({           //清衡館（天球）
      pos: [22, 12, 47],
      href: 'https://tadappi.github.io/FU-kiyohira/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './kiyo.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin9); clickableObjects.push(pin9);   

 const pin10 = createPin({           //延命千年杉（天球）
      pos: [2, 3, -10],
      href: 'https://tadappi.github.io/FU-enmei/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './enmei.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin10); clickableObjects.push(pin10);   

 const pin11 = createPin({           //レストラン清衡（link）
      pos: [-3, 6, -50],
      href: 'https://www.fujiwaranosato.com/restaurant/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './rest.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin11); clickableObjects.push(pin11);   

 const pin12 = createPin({           //えさし郷土文化館（link）
      pos: [36, 9, -12],
      href: 'https://www.esashi-iwate.gr.jp/bunka/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './kyoudo.png',
      scale: 3,
      labelHeight: 0.7,
      labelOffset: [0, 1.0, 0],
    });
    root.add(pin12); clickableObjects.push(pin12);   


    
    

    
    // ===== 疑似回転 赤ピン × 3 =====
const SPIN_PINS = [
  { 
    pos:[ 22, 12, 37],
    href:'https://tadappi.github.io/FUJIWARANOSATO-kiyohira/',          // 3D清衡館
    labelPng:'./kiyohira.png'
  },
  { 
    pos:[-16, 10,  1],
    href:'https://tadappi.github.io/FUJIWARANO-SATO-seicho/',  // 3D政庁へ
    labelPng:'./seicho.png'
  },
  { 
    pos:[-27, 12, 22],
    href:'https://tadappi.github.io/FUJIWARANO-SATO-kyara/', // 3D伽羅御所
    labelPng:'./kyara.png'
  },
];

    SPIN_PINS.forEach(({pos, href, labelPng})=>{
      const sp = createSpinningPin({
        pos, href,
        icon: './pinbrightred.png',
        baseScale: 6,
        spinSpeed: 0.8,
        minFactor: 0.06,
        labelPng,
        labelHeight: 0.5,
        labelOffset: [0, 1.0, 0],
      });
      root.add(sp);
      clickableObjects.push(sp);
      clickableSpinPins.push(sp);
    });

  }, undefined, (err)=>{
    console.error(err);
    alert('GLBの読み込みに失敗しました。パス/ファイル名をご確認ください。');
  });

  // ========================= GUI =========================
  const gui = new GUI({ title: 'Controls' });
  const params = {
    background: DEFAULT_BG,
    ambientIntensity: ambient.intensity,
    sunIntensity: sun.intensity,
    sunElevDeg: 35,
    sunAziDeg: 25,
    autoRotate: controls.autoRotate,
    rotateSpeed: controls.autoRotateSpeed,
    showGroundShadow: ground.visible,
    showAxes: false,
    rotateX: 0, rotateY: 0, rotateZ: 0
  };
  const upSun = ()=>{
    const elev = THREE.MathUtils.degToRad(params.sunElevDeg);
    const azi  = THREE.MathUtils.degToRad(params.sunAziDeg);
    const r = 100;
    sun.position.set(
      r*Math.cos(elev)*Math.cos(azi),
      r*Math.sin(elev),
      r*Math.cos(elev)*Math.sin(azi)
    );
  };
  upSun();

  gui.addColor(params, 'background').name('Background').onChange(v=> scene.background = new THREE.Color(v));
  const fL = gui.addFolder('Lighting');
  fL.add(params, 'ambientIntensity', 0, 2.5, 0.01).name('Ambient').onChange(v=> ambient.intensity = v);
  fL.add(params, 'sunIntensity', 0, 3, 0.01).name('Sun').onChange(v=> sun.intensity = v);
  fL.add(params, 'sunElevDeg', 0, 90, 1).name('Sun Elev [deg]').onChange(upSun);
  fL.add(params, 'sunAziDeg', -180, 180, 1).name('Sun Azi [deg]').onChange(upSun);
  fL.add(params, 'showGroundShadow').name('Ground shadow').onChange(v=> ground.visible = v);
  const fM = gui.addFolder('Model Rotation');
  fM.add(params, 'rotateX', -180, 180, 1).name('Rotate X [deg]');
  fM.add(params, 'rotateY', -180, 180, 1).name('Rotate Y [deg]');
  fM.add(params, 'rotateZ', -180, 180, 1).name('Rotate Z [deg]');
  const fV = gui.addFolder('View');
  fV.add(params, 'autoRotate').name('Auto rotate').onChange(v=> {
    controls.autoRotate = v;
  });
  fV.add(params, 'rotateSpeed', -3, 3, 0.1).name('Rotate speed').onChange(v=> controls.autoRotateSpeed = v);
  gui.add(params, 'showAxes').name('Show axes').onChange(v=> axes.visible = v);
　gui.close();
  

  // ========================= クリック（寄ってから小ウィンドウ＆軌道復帰用の軌道保存） =========================
  const _p = new THREE.Vector3(), _box = new THREE.Box3(), _size = new THREE.Vector3();
  
    renderer.domElement.addEventListener('click', (e)=>{
    if (_flying) return;

    // クリック（タップ）位置からレイを飛ばす
    const r = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - r.left) / r.width) * 2 - 1;
    const y = -((e.clientY - r.top) / r.height) * 2 + 1;

    raycaster.setFromCamera({ x, y }, camera);
    const hits = raycaster.intersectObjects(clickableObjects, true);
    if (!hits.length) return;

    // 当たったオブジェクトから「ピン本体」を取得
    let obj  = hits[0].object;
    let hit  = (obj.userData?.type)
      ? obj
      : (obj.parent?.userData?.type)
        ? obj.parent
        : obj;

    // hover 状態も同期（色など）
    if (hoverObject && hoverObject.userData.type === 'pin') {
      if (!hoverObject.userData.noColorSwap) {
        hoverObject.material = hoverObject.userData.mats.blue;
      }
    }
    hoverObject = hit;
    if (hoverObject && hoverObject.userData.type === 'pin') {
      if (!hoverObject.userData.noColorSwap) {
        hoverObject.material = hoverObject.userData.mats.red;
      }
    }

    const ud = hoverObject.userData || {};
    const href = ud.href;
    if (!href) return;

    // ここから下は、元のコードそのまま続けてOK
    // （軌道位置を保存して寄りカメラ → 小ウィンドウ → 軌道復帰、の処理）

  

    
    // この時点の「軌道上の位置」を記録（autoRotate中ならそのまま、そうでなければ基準軌道）
    if (hasBaseOrbit) {
      if (controls.autoRotate) {
        orbitPosBeforeFly.copy(camera.position);
        orbitTargetBeforeFly.copy(controls.target);
      } else {
        orbitPosBeforeFly.copy(baseOrbitPos);
        orbitTargetBeforeFly.copy(baseOrbitTarget);
      }
      hasOrbitBeforeFly = true;
    } else {
      hasOrbitBeforeFly = false;
    }

    markUserInteraction();

    hoverObject.getWorldPosition(_p);
    const p = _p.clone();
    const d0 = camera.position.distanceTo(p);

    let desiredDist = THREE.MathUtils.clamp(d0 * 0.35, 10, 120);
    if (hoverObject.isMesh){
      _box.setFromObject(hoverObject); _box.getSize(_size);
      const r = Math.max(_size.x, _size.y, _size.z) * 0.5;
      desiredDist = THREE.MathUtils.clamp(r * 2.2, 10, 120);
    }
    const dir = camera.position.clone().sub(p).normalize();
    const autoCam = p.clone().add(dir.multiplyScalar(desiredDist));
    const destPos = (ud.camPos instanceof THREE.Vector3) ? ud.camPos.clone() : autoCam;
    const lookAt  = (ud.lookAt instanceof THREE.Vector3) ? ud.lookAt.clone() : p.clone();
    const duration = (typeof ud.flyMs === 'number') ? ud.flyMs : 1500;

    flyTo(camera, controls, destPos, lookAt, duration, ()=>{
      openOverlay(href);
    });
  });

  // ========================= ループ =========================
  const clock = new THREE.Clock();

  function tick(){
    const dt = clock.getDelta();
    const t  = clock.elapsedTime;

    // レイキャスト
    raycaster.setFromCamera(mouseNDC, camera);
    const hits = raycaster.intersectObjects(clickableObjects, true);
    let hit = null;
    if (hits.length){
      const obj = hits[0].object;
      hit = (obj.userData?.type) ? obj : (obj.parent?.userData?.type) ? obj.parent : obj;
    }

    // ホバー切替
    if (hoverObject !== hit) {
      if (hoverObject && hoverObject.userData.type === 'pin') {
        if (!hoverObject.userData.noColorSwap) {
          hoverObject.material = hoverObject.userData.mats.blue;
        }
      }
      hoverObject = hit;
      if (hoverObject && hoverObject.userData.type === 'pin') {
        if (!hoverObject.userData.noColorSwap) {
          hoverObject.material = hoverObject.userData.mats.red;
        }
      }
      renderer.domElement.style.cursor = hoverObject ? 'pointer' : 'default';
    }

    // ラベルの比率フィット
    clickableObjects.forEach(obj=>{
      const lbl = obj.userData?.label;
      if (!lbl || !lbl.userData?.fitByImage) return;
      const img = lbl.material.map?.image;
      if (img && img.width && img.height){
        const h = lbl.userData.targetH;
        const w = h * (img.width / img.height);
        lbl.scale.set(w, h, 1);
        lbl.userData.fitByImage = false;
      }
    });

    // 疑似回転アニメ
    clickableSpinPins.forEach(sp=>{
      const conf = sp.userData.spin;
      const factor = conf.min + (1-conf.min) * Math.abs(Math.cos(t * conf.speed + conf.phase));
      sp.scale.x = conf.base * factor;
      sp.scale.y = conf.base;
    });

    // モデル回転
    if (root){
      root.rotation.set(
        THREE.MathUtils.degToRad(params.rotateX),
        THREE.MathUtils.degToRad(params.rotateY),
        THREE.MathUtils.degToRad(params.rotateZ)
      );
    }

    // 無操作10秒で「距離＆高さは基準、方位は今のまま」でオートローテ再開
    const nowMs = performance.now();
    const overlayVisible = overlay.classList.contains('visible');
    if (idleReturnArmed && !overlayVisible && !_flying && hasBaseOrbit && params.autoRotate){
      if (nowMs - lastUserInputTime > IDLE_TIMEOUT_MS){
        idleReturnArmed = false;

        // 基準の軌道中心
        const baseCenter = baseOrbitTarget.clone(); // 普通は (0,0,0) :contentReference[oaicite:1]{index=1}
        // 基準軌道のベクトル（中心→カメラ）
        const baseVec    = baseOrbitPos.clone().sub(baseCenter);
        const baseRadius = baseVec.length();
        const baseY      = baseOrbitPos.y - baseCenter.y;

        // 今のカメラの「方位」（Y軸周り）だけ取り出す
        const curVec = camera.position.clone().sub(baseCenter);
        const yaw    = Math.atan2(curVec.z, curVec.x);  // 東西南北

        // 基準の距離＆高さから水平方向の半径を計算
        const horizRadius = Math.max(
          1e-3,
          Math.sqrt(Math.max(0, baseRadius * baseRadius - baseY * baseY))
        );

        // 方位は今のまま、距離＆高さは基準に合わせた位置
        const destPos = new THREE.Vector3(
          baseCenter.x + horizRadius * Math.cos(yaw),
          baseCenter.y + baseY,
          baseCenter.z + horizRadius * Math.sin(yaw)
        );
        const destTarget = baseCenter;

        flyTo(
          camera,
          controls,
          destPos,
          destTarget,
          2000,
          ()=>{
            controls.autoRotate = true;
            params.autoRotate = true;
          }
        );
      }
    }
    
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  // リサイズ
  window.addEventListener('resize', ()=>{
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>

























































